#define _GNU_SOURCE

#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <net/if.h>
#include <ifaddrs.h>
#include <netinet/in.h>
#include <netdb.h>
#include <jansson.h>

#include "pmhelper.h"
#include "node.h"

int CIB_DEFAULT_TIMEOUT = 10*60;
node_t* cib_nodes = NULL;

json_t *
get_cibnode_by_uid(const char *uid)
{
    node_t *cib;
    cib = get_node_by_uid(cib_nodes, uid);
    if (cib) {
        return cib->json;
    }
    return NULL;
}

void
generate_cib_from_ifaces()
{
    printf("Generate cib from interfaces: \n");
    struct ifaddrs *ifaddr, *interface;
    struct if_nameindex *if_nidxs, *iface;
    int family, s, n;
    char address[NI_MAXHOST], *path;
    void *iter;

    json_t *root = json_object();

    if ((if_nidxs = if_nameindex()) == NULL )
    {
        //TODO: Write to error log
    }
    if (getifaddrs(&ifaddr) == -1) {
        //TODO: Write to error log
        perror("getifaddrs");
        exit(EXIT_FAILURE);
    }

    //For every iface name
    for (iface = if_nidxs; iface->if_index != 0 || iface->if_name != NULL; iface++)
    {
        json_object_set(root, iface->if_name, json_object());
        json_object_set(json_object_get(root, iface->if_name), "description", json_string(new_string("autogenerated CIB node for local interface", iface->if_name)));
        json_object_set(json_object_get(root, iface->if_name), "filename", json_string(new_string(iface->if_name, ".cib")));
        json_object_set(json_object_get(root, iface->if_name), "expire", json_integer(-1.0));
        json_object_set(json_object_get(root, iface->if_name), "link", json_boolean(false));
        json_object_set(json_object_get(root, iface->if_name), "priority", json_integer(0));
        json_object_set(json_object_get(root, iface->if_name), "properties", json_array());
        json_array_append(json_object_get(json_object_get(root, iface->if_name), "properties"), json_array());
        json_array_append(json_object_get(json_object_get(root, iface->if_name), "properties"), json_array());

        json_t *interface_array = json_array_get(json_object_get(json_object_get(root, iface->if_name), "properties"), 0);
        json_array_append(interface_array, json_object());
        json_object_set(json_array_get(interface_array, 0), "interface", json_object());
        json_object_set(json_object_get(json_array_get(interface_array, 0), "interface"), "precedence", json_integer(2));
        json_object_set(json_object_get(json_array_get(interface_array, 0), "interface"), "value", json_string(iface->if_name));
        json_object_set(json_array_get(interface_array, 0), "local_interface", json_object());
        json_object_set(json_object_get(json_array_get(interface_array, 0), "local_interface"), "precedence", json_integer(2));
        json_object_set(json_object_get(json_array_get(interface_array, 0), "local_interface"), "value", json_boolean(true));
    }

    //For every iface name + ip version combination
    for (interface = ifaddr, n = 0; interface != NULL; interface = interface->ifa_next, n++) {
        if (interface->ifa_addr == NULL || interface->ifa_addr->sa_family == AF_PACKET)
            continue;

        family = interface->ifa_addr->sa_family;

        s = getnameinfo(interface->ifa_addr,
                    (family == AF_INET) ? sizeof(struct sockaddr_in) :
                                            sizeof(struct sockaddr_in6),
                    address, NI_MAXHOST,
                    NULL, 0, NI_NUMERICHOST);
        if (s != 0) {
            printf("getnameinfo() failed: %s\n", gai_strerror(s));
            exit(EXIT_FAILURE);
        }

        iter = json_object_iter(root);
        while(iter){
            if(strcmp(json_object_iter_key(iter), interface->ifa_name) == 0){
                json_t *ip_array = json_array_get(json_object_get(json_object_get(root, interface->ifa_name), "properties"), 1);

                if(family == AF_INET){
                    json_array_append(ip_array, json_object());
                    json_object_set(json_array_get(ip_array, 0), "ip_version", json_object());
                    json_object_set(json_object_get(json_array_get(ip_array, 0), "ip_version"), "precedence", json_integer(2));
                    json_object_set(json_object_get(json_array_get(ip_array, 0), "ip_version"), "value", json_integer(4));
                    json_object_set(json_array_get(ip_array, 0), "local_ip", json_object());
                    json_object_set(json_object_get(json_array_get(ip_array, 0), "local_ip"), "precedence", json_integer(2));
                    json_object_set(json_object_get(json_array_get(ip_array, 0), "local_ip"), "value", json_string(address));
                } else if (family == AF_INET6){
                    json_array_append(ip_array, json_object());
                    json_object_set(json_array_get(ip_array, 1), "ip_version", json_object());
                    json_object_set(json_object_get(json_array_get(ip_array, 1), "ip_version"), "precedence", json_integer(2));
                    json_object_set(json_object_get(json_array_get(ip_array, 1), "ip_version"), "value", json_integer(6));
                    json_object_set(json_array_get(ip_array, 1), "local_ip", json_object());
                    json_object_set(json_object_get(json_array_get(ip_array, 1), "local_ip"), "precedence", json_integer(2));
                    json_object_set(json_object_get(json_array_get(ip_array, 1), "local_ip"), "value", json_string(address));
                }
            }
            iter = json_object_iter_next(root, iter);
        }
    }

    iter = json_object_iter(root);
    while(iter){
        json_object_set(json_object_get(root, json_object_iter_key(iter)), "root", json_boolean(true));
        json_object_set(json_object_get(root, json_object_iter_key(iter)), "uid", json_string(json_object_iter_key(iter)));
        /* path = get_exec_path(); */
        /* strcat(path, CIB_DIR); */
        path = new_string("%s/.neat/%s", get_home_dir(), CIB_DIR);
        write_json_file(new_string("%s%s%s", path, json_object_iter_key(iter), ".cib"), json_object_get(root, json_object_iter_key(iter)));
        iter = json_object_iter_next(root, iter);
        free(path);
    }
    json_decref(root);
    freeifaddrs(ifaddr);
    printf("\n");
}

json_t *
cib_lookup(json_t *input_props)
{
    node_t *current_node = NULL;
    json_t *candidate_array = json_array();
    json_t *node_props;
    json_t *immutable_input_props = json_array();

    const char *key;
    json_t *property;

    json_array_append(candidate_array, input_props);
    printf("\n---------- CIB LOOKUP ---------\n");

    for(current_node = cib_nodes; current_node; current_node = current_node->next){
        //If every IMMUTABLE value in input_props are in current_node->properties, continue
        printf("\nNODE: %s\n", json_string_value(json_object_get(current_node->json, "uid")));
        node_props = json_object_get(current_node->json, "properties");

        //if (node_props) { printf("NODE PROPERTIES: \n%s\n", json_dumps(node_props, 0)); }
        json_array_clear(immutable_input_props);
        json_object_foreach(input_props, key, property){
            if(json_integer_value(json_object_get(property, "precedence")) == 2){
                json_array_append(immutable_input_props, property);
            }
        }
        //printf("IMMUTABLE INPUT PROPS:\n%s", json_dumps(immutable_input_props, 0));
        if(subset(node_props, immutable_input_props)){
                printf("subset found for %s\n", current_node->filename);
                continue;
        } else {
            /* FROM CIB.PY
            candidate = e + input_properties
            candidate.cib_node = e.cib_node
            candidates.append(candidate)
            */
        }
    }
    printf("\nOUTPUT FROM CIB LOOKUP: %s\n", json_dumps(candidate_array, 0));
    return candidate_array; //TODO: free
}

void
cib_start()
{
    char *path = new_string("%s/%s/%s", get_home_dir(), ".neat", CIB_DIR);
    cib_nodes = read_modified_files(cib_nodes, path);
    free(path);
}

void
cib_close()
{
    free_nodes(cib_nodes);
}
/*
int main(int argc, char const *argv[])
{
    generate_cib_from_ifaces();
    cib_start();
    json_t *candidate, *cib_lookup_result;
    size_t index, index2;
    json_t *cib_candidates = json_array();
    json_t *updated_requests = load_json_file("/home/samulars/profile_lookup.json");
    //printf("%s\n", json_dumps(updated_requests, 0));
    json_array_foreach(updated_requests, index, candidate){
        cib_lookup_result = cib_lookup(candidate);
        json_array_foreach(cib_lookup_result, index2, candidate){
            if(!subset(cib_candidates, candidate) || json_array_size(cib_candidates) == 0){
                printf("Candidate is not in cib_candidates! Adding...\n");
                json_array_append(cib_candidates, candidate);
            }
        }
    }
    return 0;
}
*/
