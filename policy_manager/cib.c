#define _GNU_SOURCE

#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <net/if.h>
#include <ifaddrs.h>
#include <netinet/in.h>
#include <netdb.h>
#include <jansson.h>

#include "pm_helper.h"
#include "node.h"

int CIB_DEFAULT_TIMEOUT = 10*60;
node_t* cib_nodes = NULL;

void
generate_cib_from_ifaces()
{
    write_log(__FILE__, __func__, LOG_NORMAL, "Generate CIB from interfaces:");
    
    struct ifaddrs *ifaddr, *interface;
    struct if_nameindex *if_nidxs, *iface;
    int family, s, n;
    char address[NI_MAXHOST];
    void *iter;

    json_t *root = json_object();

    if ((if_nidxs = if_nameindex()) == NULL )
    {
        write_log(__FILE__, __func__, LOG_ERROR, "if_nameindex() failed");
    }
    if (getifaddrs(&ifaddr) == -1) {
        write_log(__FILE__, __func__, LOG_ERROR, "getifaddrs() failed");
        //exit(EXIT_FAILURE);
    }

    //For every iface name
    for (iface = if_nidxs; iface->if_index != 0 || iface->if_name != NULL; iface++)
    {
        json_object_set(root, iface->if_name, json_object());
        json_object_set(json_object_get(root, iface->if_name), "description", json_string(new_string("%s%s", "autogenerated CIB node for local interface ", iface->if_name)));
        json_object_set(json_object_get(root, iface->if_name), "filename", json_string(new_string("%s%s", iface->if_name, ".cib")));
        json_object_set(json_object_get(root, iface->if_name), "expire", json_integer(-1.0));
        json_object_set(json_object_get(root, iface->if_name), "link", json_boolean(false));
        json_object_set(json_object_get(root, iface->if_name), "priority", json_integer(0));
        json_object_set(json_object_get(root, iface->if_name), "properties", json_array());
        json_array_append(json_object_get(json_object_get(root, iface->if_name), "properties"), json_array());
        json_array_append(json_object_get(json_object_get(root, iface->if_name), "properties"), json_array());

        json_t *interface_array = json_array_get(json_object_get(json_object_get(root, iface->if_name), "properties"), 0);
        json_array_append(interface_array, json_object());
        json_object_set(json_array_get(interface_array, 0), "interface", json_object());
        json_object_set(json_object_get(json_array_get(interface_array, 0), "interface"), "precedence", json_integer(2));
        json_object_set(json_object_get(json_array_get(interface_array, 0), "interface"), "value", json_string(iface->if_name));
        json_object_set(json_array_get(interface_array, 0), "local_interface", json_object());
        json_object_set(json_object_get(json_array_get(interface_array, 0), "local_interface"), "precedence", json_integer(2));
        json_object_set(json_object_get(json_array_get(interface_array, 0), "local_interface"), "value", json_boolean(true));
    }

    //For every iface name + ip version combination
    for (interface = ifaddr, n = 0; interface != NULL; interface = interface->ifa_next, n++) {
        if (interface->ifa_addr == NULL || interface->ifa_addr->sa_family == AF_PACKET)
            continue;

        family = interface->ifa_addr->sa_family;

        s = getnameinfo(interface->ifa_addr,
                    (family == AF_INET) ? sizeof(struct sockaddr_in) :
                                            sizeof(struct sockaddr_in6),
                    address, NI_MAXHOST,
                    NULL, 0, NI_NUMERICHOST);
        if (s != 0) {
            write_log(__FILE__, __func__, LOG_ERROR, "getnameinfo() failed: %s", gai_strerror(s));
            exit(EXIT_FAILURE);
        }

        iter = json_object_iter(root);
        while(iter){
            if(strcmp(json_object_iter_key(iter), interface->ifa_name) == 0){
                json_t *ip_array = json_array_get(json_object_get(json_object_get(root, interface->ifa_name), "properties"), 1);

                if(family == AF_INET){
                    json_array_append(ip_array, json_object());
                    json_object_set(json_array_get(ip_array, 0), "ip_version", json_object());
                    json_object_set(json_object_get(json_array_get(ip_array, 0), "ip_version"), "precedence", json_integer(2));
                    json_object_set(json_object_get(json_array_get(ip_array, 0), "ip_version"), "value", json_integer(4));
                    json_object_set(json_array_get(ip_array, 0), "local_ip", json_object());
                    json_object_set(json_object_get(json_array_get(ip_array, 0), "local_ip"), "precedence", json_integer(2));
                    json_object_set(json_object_get(json_array_get(ip_array, 0), "local_ip"), "value", json_string(address));
                } else if (family == AF_INET6){
                    json_array_append(ip_array, json_object());
                    json_object_set(json_array_get(ip_array, 1), "ip_version", json_object());
                    json_object_set(json_object_get(json_array_get(ip_array, 1), "ip_version"), "precedence", json_integer(2));
                    json_object_set(json_object_get(json_array_get(ip_array, 1), "ip_version"), "value", json_integer(6));
                    json_object_set(json_array_get(ip_array, 1), "local_ip", json_object());
                    json_object_set(json_object_get(json_array_get(ip_array, 1), "local_ip"), "precedence", json_integer(2));
                    json_object_set(json_object_get(json_array_get(ip_array, 1), "local_ip"), "value", json_string(address));
                }
            }
            iter = json_object_iter_next(root, iter);
        }
    }

    iter = json_object_iter(root);
    while(iter){
        json_object_set(json_object_get(root, json_object_iter_key(iter)), "root", json_boolean(true));
        json_object_set(json_object_get(root, json_object_iter_key(iter)), "uid", json_string(json_object_iter_key(iter)));

        char* path = new_string("%s%s%s", CIB_DIR, json_object_iter_key(iter), ".cib");
        write_json_file(path, json_object_get(root, json_object_iter_key(iter)));
        write_log(__FILE__, __func__, LOG_NORMAL, "%s", path);

        iter = json_object_iter_next(root, iter);
    }
    write_log(__FILE__, __func__, LOG_NEW_LINE, "");  //just to make console look good
    json_decref(root);
    freeifaddrs(ifaddr);
}

json_t *
cib_lookup(json_t *input_props)
{
    node_t *current_node = NULL;
    json_t *candidate_array = json_array();
    json_t *node_props;
    json_t *immutable_input_props = json_array();

    const char *key;
    json_t *property;

    json_array_append(candidate_array, input_props);

    for(current_node = cib_nodes; current_node; current_node = current_node->next){
        //If every IMMUTABLE value in input_props are in current_node->properties, continue
        node_props = json_object_get(current_node->json, "properties");

        json_array_clear(immutable_input_props);
        json_object_foreach(input_props, key, property){
            if(json_integer_value(json_object_get(property, "precedence")) == 2){
                json_array_append(immutable_input_props, property);
            }
        }

        if(subset(node_props, immutable_input_props)){
            write_log(__FILE__, __func__, LOG_DEBUG, "Subset found for %s\n", current_node->filename);
            continue;
        } else {
            /* FROM CIB.PY
            candidate = e + input_properties
            candidate.cib_node = e.cib_node
            candidates.append(candidate)
            */
        }
    }
    return candidate_array; //TODO: free
}

void
cib_start()
{
    cib_nodes = read_modified_files(cib_nodes, CIB_DIR);
}

void
cib_close()
{
    free_nodes(cib_nodes);
}